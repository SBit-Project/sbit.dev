"use strict";(self.webpackChunksbit_website=self.webpackChunksbit_website||[]).push([[3071],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},b=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),b=l(n),u=o,f=b["".concat(c,".").concat(u)]||b[u]||d[u]||a;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}b.displayName="MDXCreateElement"},1292:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={title:"SBIT Block",description:"A Block instance represents the information of a block in the SBIT network",keywords:["sbit","bitcoin","blockchain","ethereum","sbitcore","tools"],sidebar_position:3},c=void 0,l={unversionedId:"Tools/SBitcore-lib/block",id:"Tools/SBitcore-lib/block",title:"SBIT Block",description:"A Block instance represents the information of a block in the SBIT network",source:"@site/docs/Tools/SBitcore-lib/block.md",sourceDirName:"Tools/SBitcore-lib",slug:"/Tools/SBitcore-lib/block",permalink:"/sbit.dev/docs/Tools/SBitcore-lib/block",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"SBIT Block",description:"A Block instance represents the information of a block in the SBIT network",keywords:["sbit","bitcoin","blockchain","ethereum","sbitcore","tools"],sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"SBIT Address",permalink:"/sbit.dev/docs/Tools/SBitcore-lib/address"},next:{title:"Browser Builds",permalink:"/sbit.dev/docs/Tools/SBitcore-lib/browser"}},p={},d=[{value:"Block Header",id:"block-header",level:2},{value:"Transactions",id:"transactions",level:2}],b={toc:d};function u(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A Block instance represents the information of a block in the SBIT network. Given a hexadecimal string representation of the serialization of a block with its transactions, you can instantiate a Block instance. Methods are provided to calculate and check the merkle root hash (if enough data is provided), but transactions won't necessarily be valid spends, and this class won't validate them. A binary representation as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Buffer")," instance is also valid input for a Block's constructor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// instantiate a new block instance\nvar block = new Block(hexaEncodedBlock);\n\n// will verify that the corresponding block transactions match the header\nassert(block.validMerkleRoot());\n\n// blocks have several properties\nassert(block.header); // an instance of block header, more info below\nassert(block.transactions); // an array of transactions, more info below\n")),(0,a.kt)("h2",{id:"block-header"},"Block Header"),(0,a.kt)("p",null,"Each instance of Block has a BlockHeader ",(0,a.kt)("em",{parentName:"p"},"(which can be instantiated separately)"),". The header has validation methods, to verify that the block."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// will verify that the nonce demonstrates enough proof of work\nassert(block.header.validProofOfWork());\n\n// will verify that timestamp is not too far in the future\nassert(block.header.validTimestamp());\n\n// each header has the following properties\nassert(block.header.version);\nassert(block.header.prevHash);\nassert(block.header.merkleRoot);\nassert(block.header.time);\nassert(block.header.bits);\nassert(block.header.nonce);\n")),(0,a.kt)("h2",{id:"transactions"},"Transactions"),(0,a.kt)("p",null,"The set of transactions in a block is an array of instances of ",(0,a.kt)("a",{parentName:"p",href:"transaction"},"Transaction")," and can be explored by iterating on the block's ",(0,a.kt)("inlineCode",{parentName:"p"},"transactions")," member."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"for (var i in block.transactions) {\n  var transaction = block.transactions[i];\n}\n")))}u.isMDXComponent=!0}}]);