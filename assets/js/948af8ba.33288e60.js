"use strict";(self.webpackChunksbit_website=self.webpackChunksbit_website||[]).push([[6283],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?o.createElement(m,a(a({ref:t},p),{},{components:n})):o.createElement(m,a({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},574:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var o=n(7462),i=n(3366),r=(n(7294),n(3905)),a=["components"],s={title:"ZMQ",description:"Block and Transaction Broadcasting with ZeroMQ",keywords:["sbit","sbit","blockchain","ethereum"],sidebar_position:9},l=void 0,c={unversionedId:"SBit-Core/Miscellaneous/zmq",id:"SBit-Core/Miscellaneous/zmq",title:"ZMQ",description:"Block and Transaction Broadcasting with ZeroMQ",source:"@site/docs/SBit-Core/Miscellaneous/zmq.md",sourceDirName:"SBit-Core/Miscellaneous",slug:"/SBit-Core/Miscellaneous/zmq",permalink:"/sbit.dev/docs/SBit-Core/Miscellaneous/zmq",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"ZMQ",description:"Block and Transaction Broadcasting with ZeroMQ",keywords:["sbit","sbit","blockchain","ethereum"],sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Tor",permalink:"/sbit.dev/docs/SBit-Core/Miscellaneous/tor"},next:{title:"Encrypt & Unlock",permalink:"/sbit.dev/docs/User-Guide/Encrypt-and-Unlock-Sbit-Wallet"}},p={},u=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Enabling",id:"enabling",level:2},{value:"Usage",id:"usage",level:2},{value:"Remarks",id:"remarks",level:2}],d={toc:u};function h(e){var t=e.components,n=(0,i.Z)(e,a);return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://zeromq.org/"},"ZeroMQ")," is a lightweight wrapper around TCP\nconnections, inter-process communication, and shared-memory,\nproviding various message-oriented semantics such as publish/subscribe,\nrequest/reply, and push/pull."),(0,r.kt)("p",null,'The SBit Core daemon can be configured to act as a trusted "border\nrouter", implementing the SBit wire protocol and relay, making\nconsensus decisions, maintaining the local blockchain database,\nbroadcasting locally generated transactions into the network, and\nproviding a queryable RPC interface to interact on a polled basis for\nrequesting blockchain related data. However, there exists only a\nlimited service to notify external software of events like the arrival\nof new blocks or transactions.'),(0,r.kt)("p",null,"The ZeroMQ facility implements a notification interface through a set\nof specific notifiers. Currently there are notifiers that publish\nblocks and transactions. This read-only facility requires only the\nconnection of a corresponding ZeroMQ subscriber port in receiving\nsoftware; it is not authenticated nor is there any two-way protocol\ninvolvement. Therefore, subscribers should validate the received data\nsince it may be out of date, incomplete or even invalid."),(0,r.kt)("p",null,"ZeroMQ sockets are self-connecting and self-healing; that is,\nconnections made between two endpoints will be automatically restored\nafter an outage, and either end may be freely started or stopped in\nany order."),(0,r.kt)("p",null,"Because ZeroMQ is message oriented, subscribers receive transactions\nand blocks all-at-once and do not need to implement any sort of\nbuffering or reassembly."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"The ZeroMQ feature in SBit Core requires the ZeroMQ API >= 4.0.0\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeromq/libzmq/releases"},"libzmq"),".\nFor version information, see ",(0,r.kt)("a",{parentName:"p",href:"../Building/depend"},"dependencies.md"),".\nTypically, it is packaged by distributions as something like\n",(0,r.kt)("em",{parentName:"p"},"libzmq3-dev"),". The C++ wrapper for ZeroMQ is ",(0,r.kt)("em",{parentName:"p"},"not")," needed."),(0,r.kt)("p",null,"In order to run the example Python client scripts in the ",(0,r.kt)("inlineCode",{parentName:"p"},"contrib/zmq/"),"\ndirectory, one must also install ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeromq/pyzmq"},"PyZMQ"),"\n(generally with ",(0,r.kt)("inlineCode",{parentName:"p"},"pip install pyzmq"),"), though this is not necessary for daemon\noperation."),(0,r.kt)("h2",{id:"enabling"},"Enabling"),(0,r.kt)("p",null,"By default, the ZeroMQ feature is automatically compiled in if the\nnecessary prerequisites are found.  To disable, use --disable-zmq\nduring the ",(0,r.kt)("em",{parentName:"p"},"configure")," step of building sbitd:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ ./configure --disable-zmq (other options)\n")),(0,r.kt)("p",null,"To actually enable operation, one must set the appropriate options on\nthe command line or in the configuration file."),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,"Currently, the following notifications are supported:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-zmqpubhashtx=address\n-zmqpubhashblock=address\n-zmqpubrawblock=address\n-zmqpubrawtx=address\n-zmqpubsequence=address\n")),(0,r.kt)("p",null,"The socket type is PUB and the address must be a valid ZeroMQ socket\naddress. The same address can be used in more than one notification.\nThe same notification can be specified more than once."),(0,r.kt)("p",null,"The option to set the PUB socket's outbound message high water mark\n(SNDHWM) may be set individually for each notification:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-zmqpubhashtxhwm=n\n-zmqpubhashblockhwm=n\n-zmqpubrawblockhwm=n\n-zmqpubrawtxhwm=n\n-zmqpubsequencehwm=address\n")),(0,r.kt)("p",null,"The high water mark value must be an integer greater than or equal to 0."),(0,r.kt)("p",null,"For instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ sbitd -zmqpubhashtx=tcp://127.0.0.1:22501 \\\n           -zmqpubhashtx=tcp://192.168.1.2:22501 \\\n           -zmqpubrawtx=ipc:///tmp/sbitd.tx.raw \\\n           -zmqpubhashtxhwm=10000\n")),(0,r.kt)("p",null,"Each PUB notification has a topic and body, where the header\ncorresponds to the notification type. For instance, for the\nnotification ",(0,r.kt)("inlineCode",{parentName:"p"},"-zmqpubhashtx")," the topic is ",(0,r.kt)("inlineCode",{parentName:"p"},"hashtx")," (no null\nterminator) and the body is the transaction hash (32\nbytes) for all but ",(0,r.kt)("inlineCode",{parentName:"p"},"sequence")," topic. For ",(0,r.kt)("inlineCode",{parentName:"p"},"sequence"),", the body\nis structured as the following based on the type of message:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<32-byte hash>C :                 Blockhash connected\n<32-byte hash>D :                 Blockhash disconnected\n<32-byte hash>R<8-byte LE uint> : Transactionhash removed from mempool for non-block inclusion reason\n<32-byte hash>A<8-byte LE uint> : Transactionhash added mempool\n")),(0,r.kt)("p",null,"Where the 8-byte uints correspond to the mempool sequence number."),(0,r.kt)("p",null,"These options can also be provided in sbit.conf."),(0,r.kt)("p",null,"ZeroMQ endpoint specifiers for TCP (and others) are documented in the\n",(0,r.kt)("a",{parentName:"p",href:"http://api.zeromq.org/4-0:_start"},"ZeroMQ API"),"."),(0,r.kt)("p",null,"Client side, then, the ZeroMQ subscriber socket must have the\nZMQ_SUBSCRIBE option set to one or either of these prefixes (for\ninstance, just ",(0,r.kt)("inlineCode",{parentName:"p"},"hash"),"); without doing so will result in no messages\narriving. Please see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SBit-Project/sbit/contrib/zmq/zmq_sub.py"},(0,r.kt)("inlineCode",{parentName:"a"},"contrib/zmq/zmq_sub.py"))," for a working example."),(0,r.kt)("p",null,"The ZMQ_PUB socket's ZMQ_TCP_KEEPALIVE option is enabled. This means that\nthe underlying SO_KEEPALIVE option is enabled when using a TCP transport.\nThe effective TCP keepalive values are managed through the underlying\noperating system configuration and must be configured prior to connection establishment."),(0,r.kt)("p",null,"For example, when running on GNU/Linux, one might use the following\nto lower the keepalive setting to 10 minutes:"),(0,r.kt)("p",null,"sudo sysctl -w net.ipv4.tcp_keepalive_time=600"),(0,r.kt)("p",null,"Setting the keepalive values appropriately for your operating environment may\nimprove connectivity in situations where long-lived connections are silently\ndropped by network middle boxes."),(0,r.kt)("h2",{id:"remarks"},"Remarks"),(0,r.kt)("p",null,"From the perspective of sbitd, the ZeroMQ socket is write-only; PUB\nsockets don't even have a read function. Thus, there is no state\nintroduced into sbitd directly. Furthermore, no information is\nbroadcast that wasn't already received from the public P2P network."),(0,r.kt)("p",null,"No authentication or authorization is done on connecting clients; it\nis assumed that the ZeroMQ port is exposed only to trusted entities,\nusing other means such as firewalling."),(0,r.kt)("p",null,"Note that for ",(0,r.kt)("inlineCode",{parentName:"p"},"*block")," topics, when the block chain tip changes,\na reorganisation may occur and just the tip will be notified.\nIt is up to the subscriber to retrieve the chain from the last known\nblock to the new tip. Also note that no notification will occur if the tip\nwas in the active chain--as would be the case after calling invalidateblock RPC.\nIn contrast, the ",(0,r.kt)("inlineCode",{parentName:"p"},"sequence")," topic publishes all block connections and\ndisconnections."),(0,r.kt)("p",null,"There are several possibilities that ZMQ notification can get lost\nduring transmission depending on the communication type you are\nusing. sbitd appends an up-counting sequence number to each\nnotification which allows listeners to detect lost notifications."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"sequence")," topic refers specifically to the mempool sequence\nnumber, which is also published along with all mempool events. This\nis a different sequence value than in ZMQ itself in order to allow a total\nordering of mempool events to be constructed."))}h.isMDXComponent=!0}}]);