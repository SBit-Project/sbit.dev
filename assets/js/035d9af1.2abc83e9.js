"use strict";(self.webpackChunksbit_website=self.webpackChunksbit_website||[]).push([[294],{3905:function(t,e,n){n.d(e,{Zo:function(){return l},kt:function(){return f}});var r=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,o=function(t,e){if(null==t)return{};var n,r,o={},a=Object.keys(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var c=r.createContext({}),u=function(t){var e=r.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},l=function(t){var e=u(t.components);return r.createElement(c.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},p=r.forwardRef((function(t,e){var n=t.components,o=t.mdxType,a=t.originalType,c=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),p=u(n),f=o,m=p["".concat(c,".").concat(f)]||p[f]||d[f]||a;return n?r.createElement(m,i(i({ref:e},l),{},{components:n})):r.createElement(m,i({ref:e},l))}));function f(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:o,i[1]=s;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3596:function(t,e,n){n.r(e),n.d(e,{assets:function(){return l},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={title:"Introduction",description:"About SRC20",keywords:["sbit","smart contract","src20","ethereum"],sidebar_position:1},c=void 0,u={unversionedId:"Smart-Contract/Smart-Contract",id:"Smart-Contract/Smart-Contract",title:"Introduction",description:"About SRC20",source:"@site/docs/Smart-Contract/Smart-Contract.md",sourceDirName:"Smart-Contract",slug:"/Smart-Contract/",permalink:"/sbit.dev/docs/Smart-Contract/",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Introduction",description:"About SRC20",keywords:["sbit","smart contract","src20","ethereum"],sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Basic wallet functions",permalink:"/sbit.dev/docs/User-Guide/Sbit-Wallet-Tutorial"},next:{title:"SBIT Docker Container",permalink:"/sbit.dev/docs/Smart-Contract/Running-SBit/sbit-docker"}},l={},d=[{value:"About SRC20",id:"about-src20",level:2},{value:"Sbit Smart Contract Limitations",id:"sbit-smart-contract-limitations",level:2}],p={toc:d};function f(t){var e=t.components,n=(0,o.Z)(t,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"about-src20"},"About SRC20"),(0,a.kt)("p",null,"SRC20 is the implementation of a standard API for tokens within smart contracts on Sbit\uff0cbasically it is the same as ERC20.\nMethods and Events\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"function name() constant returns (string name)\nfunction symbol() constant returns (string symbol)\nfunction decimals() constant returns (uint8 decimals)\nfunction totalSupply() constant returns (uint256 totalSupply)\nfunction balanceOf(address _owner) constant returns (uint256 balance)\nfunction transfer(address _to, uint256 _value) returns (bool success)\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success)\nfunction approve(address _spender, uint256 _value) returns (bool success)\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining)\nevent Transfer(address indexed _from, address indexed _to, uint256 _value)\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value)\n")),(0,a.kt)("h2",{id:"sbit-smart-contract-limitations"},"Sbit Smart Contract Limitations"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"EVM smart contracts cannot receive coins from or send coins to any address type other than pay-to-pubkeyhash (starts with Q) addresses. This is due to a limitation in the EVM"),(0,a.kt)("li",{parentName:"ul"},"Contracts are not allowed to create contracts with an initial endowment of coins. The contract must first be created, and then be sent coins in a separate transaction. Humans are also not allowed to create contracts with an initial endowment of coins."),(0,a.kt)("li",{parentName:"ul"},"Although all of the infrastructure is present, Sbit Core does not currently parse Solidity event data. You must parse this yourself using either searchlogs or -record-log-opcodes features."),(0,a.kt)("li",{parentName:"ul"},"It is not possible to send a contract coins without also executing the contract. This is also the case of Ethereum. This was promised in earlier discussions and technically does work, but due to lack of time for testing this feature was disabled. We hope to reenable this feature with release of the x86 virtual machine in 2020."),(0,a.kt)("li",{parentName:"ul"},"In Sbit there can be multiple addresses used to create a proof-of-stake block. However, the EVM can only see the first output using the coinbase operation in Solidity (this address is also the one registered for the continuous staker rewards after 500 blocks).")))}f.isMDXComponent=!0}}]);