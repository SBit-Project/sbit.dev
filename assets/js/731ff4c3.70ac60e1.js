"use strict";(self.webpackChunksbit_website=self.webpackChunksbit_website||[]).push([[9676],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=i,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1849:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return c}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],l={title:"Sbit Transaction",description:"Sbit Transaction",keywords:["sbit","bitcoin","blockchain","ethereum","sbitcore","tools"],sidebar_position:13},s=void 0,u={unversionedId:"Tools/SBitcore-lib/transaction",id:"Tools/SBitcore-lib/transaction",title:"Sbit Transaction",description:"Sbit Transaction",source:"@site/docs/Tools/SBitcore-lib/transaction.md",sourceDirName:"Tools/SBitcore-lib",slug:"/Tools/SBitcore-lib/transaction",permalink:"/sbit.dev/docs/Tools/SBitcore-lib/transaction",draft:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Sbit Transaction",description:"Sbit Transaction",keywords:["sbit","bitcoin","blockchain","ethereum","sbitcore","tools"],sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"Sbit Script",permalink:"/sbit.dev/docs/Tools/SBitcore-lib/script"},next:{title:"Sbit Unit",permalink:"/sbit.dev/docs/Tools/SBitcore-lib/unit"}},p={},c=[{value:"Multisig Transactions",id:"multisig-transactions",level:2},{value:"Adding inputs",id:"adding-inputs",level:2},{value:"PublicKeyHashInput",id:"publickeyhashinput",level:3},{value:"MultisigScriptHashInput",id:"multisigscripthashinput",level:3},{value:"Signing a Transaction",id:"signing-a-transaction",level:2},{value:"Handling Outputs",id:"handling-outputs",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Serialization Checks",id:"serialization-checks",level:2},{value:"Fee calculation",id:"fee-calculation",level:2},{value:"Time-Locking transaction",id:"time-locking-transaction",level:2}],d={toc:c};function h(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Sbitcore provides a very simple API for creating transactions. We expect this API to be accessible for developers without knowing the working internals of SBIT in deep detail. What follows is a small introduction to transactions with some basic knowledge required to use this API."),(0,r.kt)("p",null,"A Transaction contains a set of inputs and a set of outputs. Each input contains a reference to another transaction's output, and a signature that allows the value referenced in that output to be used in this transaction."),(0,r.kt)("p",null,"Note also that an output can be used only once. That's why there's a concept of \"change address\" in the SBIT ecosystem: if an output of 10 BTC is available for me to spend, but I only need to transmit 1 BTC, I'll create a transaction with two outputs, one with 1 BTC that I want to spend, and the other with 9 BTC to a change address, so I can spend this 9 BTC with another private key that I own."),(0,r.kt)("p",null,'So, in order to transmit a valid transaction, you must know what other transactions on the network store outputs that have not been spent and that are available for you to spend (meaning that you have the set of keys that can validate you own those funds). The unspent outputs are usually referred to as "utxo"s.'),(0,r.kt)("p",null,"Let's take a look at some very simple transactions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var transaction = new Transaction()\n    .from(utxos)          // Feed information about what unspent outputs one can use\n    .to(address, amount)  // Add an output with the given amount of satoshis\n    .change(address)      // Sets up a change address where the rest of the funds will go\n    .sign(privkeySet)     // Signs all the inputs it can\n")),(0,r.kt)("p",null,"You can obtain the input and output total amounts of the transaction in satoshis by accessing the fields ",(0,r.kt)("inlineCode",{parentName:"p"},"inputAmount")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"outputAmount"),"."),(0,r.kt)("p",null,"Now, this could just be serialized to hexadecimal ASCII values (",(0,r.kt)("inlineCode",{parentName:"p"},"transaction.serialize()"),") and sent over to the sbitd reference client."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"sbitd-cli sendrawtransaction <serialized transaction>\n")),(0,r.kt)("p",null,"You can also override the fee estimation with another amount, specified in satoshis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var transaction = new Transaction().fee(5430); // Minimum non-dust amount\nvar transaction = new Transaction().fee(1e8);  // Generous fee of 1 BTC\n")),(0,r.kt)("h2",{id:"multisig-transactions"},"Multisig Transactions"),(0,r.kt)("p",null,"To send a transaction to a multisig address, the API is the same as in the above example. To spend outputs that require multiple signatures, the process needs extra information: the public keys of the signers that can unlock that output."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var multiSigTx = new Transaction()\n    .from(utxo, publicKeys, threshold)\n    .change(address)\n    .sign(myKeys);\n\nvar serialized = multiSigTx.toObject();\n")),(0,r.kt)("p",null,"This can be serialized and sent to another party, to complete with the needed signatures:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var multiSigTx = new Transaction(serialized)\n    .sign(anotherSetOfKeys);\n\nassert(multiSigTx.isFullySigned());\n")),(0,r.kt)("p",null,"Also, you can just send over the signature for your private key:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var multiSigTx = new Transaction()\n    .from(utxo, publicKeys, threshold)\n    .change(address);\n\nvar signature = multiSigTx.getSignatures(privateKey)[0];\nconsole.log(JSON.stringify(signature));\nconsole.log(signature.toObject());\nconsole.log(signature.signature.toString()); // Outputs a DER signature\nconsole.log(signature.sigtype);\n")),(0,r.kt)("p",null,"Transfer that over the wire, and on the other side, apply it to a transaction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"assert(transaction.isValidSignature(receivedSig));\ntransaction.applySignature(receivedSig);\n")),(0,r.kt)("h2",{id:"adding-inputs"},"Adding inputs"),(0,r.kt)("p",null,"Sbitcore contains two implementations of ",(0,r.kt)("inlineCode",{parentName:"p"},"Input"),", one for spending ",(0,r.kt)("em",{parentName:"p"},"Pay to Public Key Hash")," outputs (called ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicKeyHashInput"),") and another to spend ",(0,r.kt)("em",{parentName:"p"},"Pay to Script Hash")," outputs for which the redeem script is a Multisig script (called ",(0,r.kt)("inlineCode",{parentName:"p"},"MultisigScriptHashInput"),")."),(0,r.kt)("p",null,"All inputs have the following five properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"prevTxId"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"Buffer")," with the id of the transaction with the output this input is spending"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"outputIndex"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," the index of the output in the previous transaction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sequenceNumber"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"number"),", the sequence number"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"script"),": the ",(0,r.kt)("inlineCode",{parentName:"li"},"Script")," instance for this input. Usually called ",(0,r.kt)("inlineCode",{parentName:"li"},"scriptSig")," in the SBIT community."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"output"),": if available, a ",(0,r.kt)("inlineCode",{parentName:"li"},"Output")," instance of the output associated with this input.")),(0,r.kt)("p",null,"Both ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicKeyHashInput")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MultisigScriptHashInput")," cache the information about signatures, even though this information could somehow be encoded in the script. Both need to have the ",(0,r.kt)("inlineCode",{parentName:"p"},"output")," property set in order to calculate the ",(0,r.kt)("inlineCode",{parentName:"p"},"sighash")," so signatures can be created."),(0,r.kt)("p",null,"Some methods related to adding inputs are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"from"),": A high level interface to add an input from a UTXO. It has a series of variants:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from(utxo)"),": add an input from an"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from(utxos)"),": same as above, but passing in an array of Unspent Outputs."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from(utxo, publicKeys, threshold)"),": add an input that spends a UTXO with a P2SH output for a Multisig script. The ",(0,r.kt)("inlineCode",{parentName:"li"},"publicKeys")," argument is an array of public keys, and ",(0,r.kt)("inlineCode",{parentName:"li"},"threshold")," is the number of required signatures in the Multisig script."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"addInput"),": Performs a series of checks on an input and appends it to the end of the ",(0,r.kt)("inlineCode",{parentName:"p"},"input")," vector and updates the amount of incoming SBITs of the transaction.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"uncheckedAddInput"),": adds an input to the end of the ",(0,r.kt)("inlineCode",{parentName:"p"},"input")," vector and updates the ",(0,r.kt)("inlineCode",{parentName:"p"},"inputAmount")," without performing any checks."))),(0,r.kt)("h3",{id:"publickeyhashinput"},"PublicKeyHashInput"),(0,r.kt)("p",null,"This input uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"script")," property to mark the input as unsigned if the script is empty."),(0,r.kt)("h3",{id:"multisigscripthashinput"},"MultisigScriptHashInput"),(0,r.kt)("p",null,"This input contains a set of signatures in a ",(0,r.kt)("inlineCode",{parentName:"p"},"signatures")," property, and each time a signature is added, a potentially partial and/or invalid script is created. The ",(0,r.kt)("inlineCode",{parentName:"p"},"isFullySigned")," method will only return true if all needed signatures are already added and valid. If ",(0,r.kt)("inlineCode",{parentName:"p"},"addSignature")," is added after all need signatures are already set, an exception will be thrown."),(0,r.kt)("h2",{id:"signing-a-transaction"},"Signing a Transaction"),(0,r.kt)("p",null,"The following methods are used to manage signatures for a transaction:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"getSignatures"),": takes an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"PrivateKey")," or strings from which a ",(0,r.kt)("inlineCode",{parentName:"p"},"PrivateKey")," can be instantiated; the transaction to be signed; the kind of ",(0,r.kt)("inlineCode",{parentName:"p"},"signature hash to use"),". Returns an array of objects with the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signature"),": an instance of ",(0,r.kt)("inlineCode",{parentName:"li"},"Signature")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"prevTxId"),": this input's ",(0,r.kt)("inlineCode",{parentName:"li"},"prevTxId"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"outputIndex"),": this input's ",(0,r.kt)("inlineCode",{parentName:"li"},"outputIndex"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"inputIndex"),": this input's index in the transaction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sigtype"),': the "sighash", the type of transaction hash used to calculate the signature'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"publicKey"),": a ",(0,r.kt)("inlineCode",{parentName:"li"},"PublicKey")," of the ",(0,r.kt)("inlineCode",{parentName:"li"},"PrivateKey")," used to create the signature"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"addSignature"),": takes an element outputed by ",(0,r.kt)("inlineCode",{parentName:"p"},"getSignatures")," and applies the signature to this input (modifies the script to include the new signature).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"clearSignatures"),": removes all signatures for this input")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"isFullySigned"),": returns true if the input is fully signed"))),(0,r.kt)("h2",{id:"handling-outputs"},"Handling Outputs"),(0,r.kt)("p",null,"Outputs can be added by:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"addOutput(output)")," method, which pushes an ",(0,r.kt)("inlineCode",{parentName:"li"},"Output")," to the end of the ",(0,r.kt)("inlineCode",{parentName:"li"},"outputs")," property and updates the ",(0,r.kt)("inlineCode",{parentName:"li"},"outputAmount")," field. It also clears signatures (as the hash of the transaction may have changed) and updates the change output."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"to(address, amount)")," method, that adds an output with the script that corresponds to the given address. Builds an output and calls the ",(0,r.kt)("inlineCode",{parentName:"li"},"addOutput")," method."),(0,r.kt)("li",{parentName:"ul"},"Specifying a ",(0,r.kt)("a",{parentName:"li",href:"#Fee_calculation"},"change address"))),(0,r.kt)("p",null,"To remove all outputs, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"clearOutputs()"),", which preserves change output configuration."),(0,r.kt)("h2",{id:"serialization"},"Serialization"),(0,r.kt)("p",null,"There are a series of methods used for serialization:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toObject"),": Returns a plain JavaScript object with no methods and enough information to fully restore the state of this transaction. Using other serialization methods (except for ",(0,r.kt)("inlineCode",{parentName:"li"},"toJSON"),") will cause a some information to be lost."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toJSON"),": Will be called when using ",(0,r.kt)("inlineCode",{parentName:"li"},"JSON.stringify")," to return JSON-encoded string using the output from ",(0,r.kt)("inlineCode",{parentName:"li"},"toObject"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toString")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"uncheckedSerialize"),": Returns an hexadecimal serialization of the transaction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"serialize"),": Does a series of checks before serializing the transaction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"inspect"),": Returns a string with some information about the transaction (currently a string formatted as ",(0,r.kt)("inlineCode",{parentName:"li"},"<Transaction 000...000>"),", that only shows the serialized value of the transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toBuffer"),": Serializes the transaction for sending over the wire in the SBIT network"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toBufferWriter"),": Uses an already existing BufferWriter to copy over the serialized transaction")),(0,r.kt)("h2",{id:"serialization-checks"},"Serialization Checks"),(0,r.kt)("p",null,"When serializing, the sbitcore library performs a series of checks. These can be disabled by providing an object to the ",(0,r.kt)("inlineCode",{parentName:"p"},"serialize")," method with the checks that you'll like to skip."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"disableLargeFees")," avoids checking that the fee is no more than ",(0,r.kt)("inlineCode",{parentName:"li"},"Transaction.FEE_PER_KB * Transaction.FEE_SECURITY_MARGIN * size_in_kb"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"disableSmallFees")," avoids checking that the fee is less than ",(0,r.kt)("inlineCode",{parentName:"li"},"Transaction.FEE_PER_KB * size_in_kb / Transaction.FEE_SECURITY_MARGIN"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"disableIsFullySigned")," does not check if all inputs are fully signed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"disableDustOutputs")," does not check for dust outputs being generated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"disableMoreOutputThanInput")," avoids checking that the sum of the output amounts is less than or equal to the sum of the amounts for the outputs being spent in the transaction")),(0,r.kt)("p",null,"These are the current default values in the sbitcore library involved on these checks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Transaction.FEE_PER_KB"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"10000")," (satoshis per kilobyte)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Transaction.FEE_SECURITY_MARGIN"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"15")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Transaction.DUST_AMOUNT"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"546")," (satoshis)")),(0,r.kt)("h2",{id:"fee-calculation"},"Fee calculation"),(0,r.kt)("p",null,"When outputs' value don't sum up to the same amount that inputs, the difference in SBITs goes to the miner of the block that includes this transaction. The concept of a \"change address\" usually is associated with this: an output with an address that can be spent by the creator of the transaction."),(0,r.kt)("p",null,"For this reason, some methods in the Transaction class are provided:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"change(address)"),": Set up the change address. This will set an internal ",(0,r.kt)("inlineCode",{parentName:"li"},"_changeScript")," property that will store the change script associated with that address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fee(amount)"),": Sets up the exact amount of fee to pay. If no change address is provided, this will raise an exception."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getFee()"),": returns the estimated fee amount to be paid, based on the size of the transaction, but disregarding the priority of the outputs.")),(0,r.kt)("p",null,"Internally, a ",(0,r.kt)("inlineCode",{parentName:"p"},"_changeIndex")," property stores the index of the change output (so it can get updated when a new input or output is added)."),(0,r.kt)("h2",{id:"time-locking-transaction"},"Time-Locking transaction"),(0,r.kt)("p",null,"All SBIT transactions contain a locktime field. The locktime indicates the earliest time a transaction can be added to the blockchain. Locktime allows signers to create time-locked transactions which will only become valid in the future, giving the signers a chance to change their minds. Locktime can be set in the form of a SBIT block height (the transaction can only be included in a block with a higher height than specified) or a linux timestamp (transaction can only be confirmed after that time)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var future = new Date(2025,10,30); // Sun Nov 30 2025\nvar transaction = new Transaction()\n  .lockUntilDate(future);\nconsole.log(transaction.getLockTime());\n// output similar to: Sun Nov 30 2025 00:00:00 GMT-0300 (ART)\n")))}h.isMDXComponent=!0}}]);